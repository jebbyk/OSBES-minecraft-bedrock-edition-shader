// __multiversion__

#include "fragmentVersionCentroid.h"

#if __VERSION__ >= 300
	#ifndef BYPASS_PIXEL_SHADER
		#if defined(TEXEL_AA) && defined(TEXEL_AA_FEATURE)
			_centroid in highp vec2 uv0;
			_centroid in vec2 uv1;
		#else
			_centroid in highp vec2 uv0;
			_centroid in vec2 uv1;
		#endif
	#endif //BYPASS_PIXEL_SHADER
#else
	#ifndef BYPASS_PIXEL_SHADER
		varying highp vec2 uv0;
		varying vec2 uv1;
	#endif	//BYPASS_PIXEL_SHADER
#endif //VERSION


varying float isRain;

varying float isWater;
varying float isUnderWater;
varying vec4 color;
varying highp vec4 position;// Get pixel position in world space (used for calculate fake normals)
varying highp vec4 relativePosition;// Calculates from vec4 position
//#ifdef FOG
	varying vec4 fogColor;
//#endif //FOG


#include "uniformPerFrameConstants.h"
#include "uniformShaderConstants.h"
#include "util.h"

uniform float TOTAL_REAL_WORLD_TIME;

#include "includes/constant.h"
#include "includes/func.glsl"

LAYOUT_BINDING(0) uniform sampler2D TEXTURE_0;
LAYOUT_BINDING(1) uniform sampler2D TEXTURE_1;
LAYOUT_BINDING(2) uniform sampler2D TEXTURE_2;


varying vec4 blueFog;
varying vec4 milkyFog;

void main()
{
	#ifdef BYPASS_PIXEL_SHADER
		gl_FragColor = vec4(1.0, 0, 0, 1.0);
		return;
	#else



	///////////////////////////////////////////////////////////////////////////////////////

	// By default (with default texture pack) result "megatexture" demensions is 1.0 x 0.5
	// but wtih my texture pack I have 1.0 x ture2D1.0. with your custom texuture pack you should check result texture  dimensions

	// calculate texcoord
	float intervalMult = 1.0/64.0;

	vec2 albedoTexCoord = fract(uv0 * vec2(32.0)) * vec2(intervalMult);
	vec2 normalTexCoord = albedoTexCoord - vec2(0.0, intervalMult);
	vec2 merTexCoord = albedoTexCoord - vec2(intervalMult, 0.0);

	// Top left texture - default texture/albedo
 	vec4 albedo = texelFetch(TEXTURE_0, ivec2((uv0 - albedoTexCoord) * 1024.0), 0);

	bool btranslucent = color.a == 0.0;
	if(color.g + color.g > color.b + color.r && !btranslucent){
		albedo.rgb *= mix(normalize(color.rgb), color.rgb, 0.5);
	} else {
		albedo.rgb *= btranslucent ? color.rgb : sqrt(color.rgb);
	}
		albedo.rgb = toLinear(albedo.rgb);


	// default blue/flat normalvalue to fill normalMap if there is no normal texture.
	vec3 normalMap = vec3(0.0, 0.0, 1.0) * 0.5 + 0.5;

	// default zero
	vec3 merMap = vec3(0.0, 0.0, 0.0);

	#if defined(BLEND)
		if(isWater >  0.9){
			float movement = TOTAL_REAL_WORLD_TIME * 0.1;
			float wnScale = 0.3;
			vec2 waterNormalOffset = vec2(4.0/32.0, 0.0);

			// TODO: resolve interpolation issues on edges using a more correct way (currently it is wierd)
			vec3 n1 = texture2D(TEXTURE_0, fract(position.xz*wnScale - movement*wnScale * 4.0)/33.0 + waterNormalOffset).rgb;
			vec3 n2 = texture2D(TEXTURE_0, fract(position.xz*0.3*wnScale + movement*wnScale)/33.0 + waterNormalOffset).rgb;
			normalMap = n1 * 0.5 + n2 * 0.5;
		}
	#else
		// Bottom left texture - normalmaps texture
		vec4 normalTexture = texelFetch(TEXTURE_0, ivec2((uv0 - normalTexCoord) * 1024.0), 0);
		normalMap = mix(normalMap, normalTexture.rgb, normalTexture.a);
	#endif

	// Top right texture - mer / metallic-roughness
	vec4 merTexture = texelFetch(TEXTURE_0, ivec2((uv0 - merTexCoord) * 1024.0), 0);
		merMap = mix(merMap, merTexture.rgb, merTexture.a);

	float metallic = 0.0;
	float roughness = 0.0;
	float reflectivity = 0.0;

	#if !defined(BLEND)
		metallic = clamp(merMap.g, 0.02, 0.9);

		roughness = pow(1.0-dot(merMap.rg, vec2(0.9, 0.1)), 2.0);
		reflectivity = max(1.0-clamp(roughness * 13.0, 0.0, 1.0), 0.0);
	#else
		if(isWater > 0.9){
			metallic = 0.0, roughness = 0.2, reflectivity = 1.0;
		} else {
			metallic = clamp(merMap.g, 0.02, 0.9);

			roughness = pow(1.0-dot(merMap.rg, vec2(0.9, 0.1)), 2.0);
			reflectivity = max(1.0-clamp(roughness * 13.0, 0.0, 1.0), 0.0);
		}
	#endif
		roughness = clamp(roughness, 0.0, 1.0);

	vec3 rawNormalVector = normalize(cross(dFdx(position.xyz), dFdy(position.xyz)));

	vec3 tangentVector = getTangentVector(rawNormalVector);
		tangentVector = normalize(tangentVector);

	vec3 binormal = normalize(cross(tangentVector, rawNormalVector));

	mat3 tbnMatrix = mat3(tangentVector.x, binormal.x, rawNormalVector.x,
		tangentVector.y, binormal.y, rawNormalVector.y,
		tangentVector.z, binormal.z, rawNormalVector.z);

	// change the normalMap range from 0.0 - 1.0 to -1.0 - 1.0
  		normalMap = normalMap * 2.0-1.0;
		
		if(isWater > 0.9) normalMap.rg = normalMap.rg * 0.5;
		normalMap = vec3(normalMap.rg * normalMapStrength, normalMap.b/normalMapStrength);
		
		normalMap = normalize(normalMap * tbnMatrix);


	vec2 noiseTextureOffset = vec2(1.0/32.0, 0.0);
	float puddles = texture2D(TEXTURE_0, fract(position.xz  / puddlesScale)/32.0 + noiseTextureOffset).r;

		puddles = puddles * isRain * puddlesCovering;

		puddles = clamp(puddles, minRainWettneess, 1.0);
		puddles *= rawNormalVector.y;
		puddles = puddles * pow(uv1.y, 6.0); // No puddles in dark places like caves

	float underwaterCaustic = 0.0;

	if(isUnderWater > 0.9){
		vec2 cauLayerCoord_0 = (position.xz + vec2(position.y / 8.0)) * causticsScale + vec2(TOTAL_REAL_WORLD_TIME * causticsSpeed);
		vec2 cauLayerCoord_1 = (-position.xz - vec2(position.y / 8.0)) * causticsScale*0.876 + vec2(TOTAL_REAL_WORLD_TIME * causticsSpeed);

		vec2 noiseTexOffset = vec2(5.0/64.0, 1.0/64.0);
		float caustics = texture2D(TEXTURE_0, fract(cauLayerCoord_0)*0.015625 + noiseTexOffset).r;
			caustics += texture(TEXTURE_0, fract(cauLayerCoord_1)*0.015625 + noiseTexOffset).r;

			caustics = clamp(caustics, 0.0, 2.0);
		if(caustics > 1.0){
			caustics = 2.0 - caustics;
		}

			caustics = pow(caustics * cauStrength * (0.2 + length(FOG_COLOR.rgb)) , cauHardness);
			underwaterCaustic = caustics;
	} else {
		underwaterCaustic = 0.0;
	}



	///////////////////////////////////////////////////////////////////////////////////////


	float blockLightCoord = uv1.x;
	float skyLightCoord = uv1.y;
	float daylightBrightness = texture2D(TEXTURE_1, vec2(0, 1)).r;

	float fakeShadowMap = min(pow(skyLightCoord * 1.15, 128.0), 1.0);

	float isDay = detectDay(TEXTURE_1);
   	float isHell = detectHell(TEXTURE_1);
	float isSunrize = detectSunRize();

	// Support vectors are used for reflection and lighting/specular
	vec3 rawLightPositions = vec3(cos(sunLightAngle), sin(sunLightAngle), 0.0);
	vec3 normalizedLightPos = normalize(rawLightPositions);

	vec3 viewDirection = normalize(relativePosition.xyz);
	vec3 halfWayDir = normalize(viewDirection + normalizedLightPos);

	vec3 reflectedVector = reflect(normalize(-relativePosition.xyz), normalMap);


	float normalDotLight = max(0.0, dot(normalMap, normalizedLightPos));
	float normalDotView = max(0.001, dot(normalMap, viewDirection));
	float normalDotHalf = max(0.001, dot(normalMap, halfWayDir));

	vec3 f0 = mix(vec3(0.04), albedo.rgb, metallic);
	vec3 specFresnel = fresnelSchlick(f0, normalDotHalf);
	vec3 viewFresnel = fresnelSchlick(f0, normalDotView);



	////////////////////////////////////////////////////////////////////////////////////////

	#ifdef SEASONS_FAR
		albedo.a = 1.0; //shader LOD (far trees and water becomes opaque)
	#endif //SEASONS_FAR

	#if USE_ALPHA_TEST
		#ifdef ALPHA_TO_COVERAGE
			#define ALPHA_THRESHOLD 0.05
		#else
			#define ALPHA_THRESHOLD 0.5
		#endif //APLPHA_TO_COVERAGE
		if(albedo.a < ALPHA_THRESHOLD) discard;// Cutout leaves and grass
	#endif //USE_ALPHA_TEST



	///////////////////////////////////////////////////////////////////////////////////////

	vec3 rainSkyLightColor = vec3(0.5, 0.5, 0.5) * isRain * isDay * 0.5;
	vec3 clearSkyLightColor = pow(FOG_COLOR.rgb, vec3(3.0)) * (1.0 - isRain) * 0.5;
	vec3 milkyFogColor = mix(vec3(0.01), milkyFog.rgb, isDay);

	if(isHell > 0.9){
		clearSkyLightColor = vec3(0.0);
		rainSkyLightColor = vec3(0.0);
	}

	vec3 ambientColor = vec3(rainSkyLightColor + clearSkyLightColor) * skyLightCoord;
	vec3 sunMoonLightColor = mix(vec3(-0.4, -0.1, 1.0) * 0.1, vec3(1.0, 0.88, 0.69), isDay);

	float srcPointLights = 0.0;
	float pointLightDetection = smoothstep(daylightBrightness * skyLightCoord, 1.0, blockLightCoord);
		srcPointLights = mix(srcPointLights, blockLightCoord, pointLightDetection);
		srcPointLights = mix(srcPointLights, blockLightCoord, isRain);

	float nearPLightsBrightness = pow(srcPointLights * 1.15, 5.0);
	float overalPLightsBrightness = pow(srcPointLights, 2.0) * 0.5 + nearPLightsBrightness;
		overalPLightsBrightness *= 2.0;
		overalPLightsBrightness = clamp(overalPLightsBrightness, 0.0, 2.0);

	vec3 pointLightsTint = vec3(1.0, 0.66, 0.33);
	vec3 pointLightColor = vec3(overalPLightsBrightness) * pointLightsTint;
		ambientColor += pointLightColor;

		reflectivity *= fakeShadowMap;

	if(!(isWater > 0.9) && metallic < 0.1){
		float newAmbientOcclusion = smoothstep(0.6, 0.3, color.g);
		fakeShadowMap = mix(fakeShadowMap, 0.0, pow(newAmbientOcclusion, 2.0));
	}

	vec3 PhongLightDiffuse = (vec3(1.0) - specFresnel) * (1.0 / pi) * pow(normalDotLight, 1.8) * 10.0;
		ambientColor += PhongLightDiffuse * sunMoonLightColor * fakeShadowMap * (1.0 - isRain);
		ambientColor += vec3(isHell * 0.175); // Ambient highlighting in hell



	///////////////////////////////////////////////////////////////////////////////////////

	vec3 clearSkyColor = pow(FOG_COLOR.rgb, vec3(0.6));
	vec3 clearSkyZenithColor = vec3(0.1, 0.2, 0.4) * length(clearSkyColor);
		clearSkyZenithColor = toLinear(clearSkyZenithColor);
	vec3 rainSkyColor = vec3(0.6, 0.6, 0.6) * length(FOG_COLOR.rgb);
		rainSkyColor = toLinear(rainSkyColor);

	float skyZenithEdgeOffset = 0.7;
	float skyAttenuation = 3.0;
	float zenithSky = max(dot(reflectedVector, normalize(vec3(0.0, max(abs(relativePosition.y), 0.0), 0.0))), 0.0);
	float depthSky = 1.0-zenithSky;

	vec3 skyColor = mix(clearSkyZenithColor, clearSkyColor, pow(min(depthSky * skyZenithEdgeOffset, 1.0), skyAttenuation));
		skyColor = mix(skyColor, rainSkyColor, isRain);


		reflectedVector = reflectedVector/(reflectedVector.y + cloudReflectionFov * 4.0);

	float clouds = cloudsPerlin(4, reflectedVector.xz * cloudReflectionFov);

	float cloudsShadow = pow(clamp(clouds * 1.5, 0.0, 1.0), 0.75);

	float cloudsCutout = pow(min(clouds * 1.75, 1.0), 1.0 * isRain + 64.0 * (1.0 - isRain));

	vec3 cloudsColor = vec3(1.5) * pow(length(FOG_COLOR.gb), 2.0);
		cloudsColor = pow(cloudsColor, vec3(2.2));
	vec3 clearSkyCloudsShadowColor = (skyColor * (0.5 + pow(length(FOG_COLOR.gb), 2.0) * 0.5)) * 0.75;
	vec3 rainSkyCloudsShadowColor = cloudsColor * 2.0;
	vec3 cloudsShadowColor = mix(clearSkyCloudsShadowColor, rainSkyCloudsShadowColor, isRain);

		cloudsShadowColor = mix(cloudsShadowColor, vec3(length(cloudsShadowColor)), 0.125); //desaturate

		cloudsColor = mix(cloudsColor, cloudsShadowColor, cloudsShadow);

 	vec3 skyCloudReflection = mix(skyColor, cloudsColor, cloudsCutout * zenithSky);
		skyCloudReflection = mix(skyCloudReflection, skyCloudReflection * albedo.rgb, metallic);

	if(isUnderWater > 0.9) skyColor = toLinear(FOG_COLOR.rgb);

	vec3 specReflection = cookTorranceSpecular(normalDotLight, normalDotView, normalDotHalf, specFresnel, roughness);
		specReflection *= normalDotLight;
		specReflection *= pow(skyLightCoord, 5.0);
		specReflection *= sunMoonLightColor * (1.0-isRain);



	///////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////


	if(isRain > 0.1 && isWater < 0.1){
		albedo.rgb = mix(albedo.rgb, toLinear(vec3(0.25,0.25,0.25)), puddles * isRain);
	}
		albedo.rgb *= ambientColor;
		albedo.rgb += underwaterCaustic * albedo.rgb;

		albedo.rgb = mix(albedo.rgb, albedo.rgb * roughness, min(1.0, metallic));
		albedo.rgb = mix(albedo.rgb, skyCloudReflection, viewFresnel * reflectivity);
		for(int i = 0; i < 2; i++) albedo.rgb += specReflection;

		albedo.rgb = mix(albedo.rgb, skyColor, fogColor.a);
      
	if(isWater < 0.9 && isRain < 0.9){
		//Add blue fog everywhere when weather is good except water and hell
		albedo.rgb = mix(albedo.rgb, toLinear(blueFog.rgb), blueFog.a * pow(isDay, 2.0));
	}



      


		albedo.rgb = colorCorrection(albedo.rgb);






	/////////////////////////////////////////Debuging section///////////////////////////////////////////


	// Debug texture coordinates
	//albedo.rgb *= vec3(fract(uv0.x*32.0), fract(uv0.y*32.0), 1.0);

	// Debug position
	//albedo.rgb = sin(position.xyz/2.545) * 0.5 + 0.5;

    // Debug tile texture
	//albedo = texelFetch(TEXTURE_0, ivec2(position.xz * 128.0), 0);
	//vec3 sphereNormal = (normalize(position.xyz) + 1.0) / 2.0;
	//albedo.rgb = sphereNormal;

	//albedo.rgb = texelFetch(TEXTURE_1, ivec2(position.xz * 4.0),0).rgb;
	//albedo.rgb = texture2D(TEXTURE_1, vec2(0.0, 1.0)).rgb;

	//albedo.rgb = vec3(metallic);
	//albedo.rgb = vec3(reflectivity);
	//albedo.rgb = vec3(roughness);

	//albedo.rgb = merMap;
	//albedo.rgb = normalMap;
	//albedo.rgb = specFresnel;
	//albedo.rgb = specReflection;








	gl_FragColor = albedo;

#endif // !BYPASS_PIXEL_SHADER
}
